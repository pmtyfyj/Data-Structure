一、数据结构分类
  线性结构:数组、栈、队列、链表、哈希表...
  树结构:二叉树、二分搜索树、AVL、Trie(前缀树)、线段树、K-D树、并查集、哈夫曼树...
  图结构：邻接矩阵、邻接表
  寻路算法：本质是经典的图论算法，基本思路：
    DFS：(深度优先遍历)使用栈
    BFS：(广度优先遍历)使用队列
 数据结构+算法=程序
 LeetCode

 二、数据结构

 数组：
 最大优点快速查询，数组做好应用于索引有语义的情况，但并非所有有语义的索引都适用于数组。

 泛型：
 让我们的数据结构可以放置任何数据类型
 不可以是基本数据类型，只能是类对象
 每个基本数据类型都有对应的包装类

 时间复杂度分析：
 O(1),O(n),O(lgn),O(nlgn),O(n^2)
 大O描述的是算法的运行时间和输入数据之间的关系

 栈 Stack：
 栈是一种线性结构
 相比数组，栈对应的操作是数组的子集
 只能从一端添加元素，也只能从一端去除元素
 这一端称为栈顶
 栈是一种后进先出的数据结构(Last In First Out(LIFO))
 栈的应用：
   撤销操作
   程序调用的系统栈
   括号匹配-编译器

 队列 Queue：
 队列也是一种线性结构
 相比数组，队列对应的操作是数组的子集
 只能从一端(队尾)添加元素，只能从另一端(队首)取出元素
 队列是一种先进先出的数据结构(First In First Out(FIFO))
 数组队列
 循环队列
 应用于广度优先遍历

 链表：Linked List
 真正的动态数据结构，不需要处理固定容量的问题。但丧失了随机访问的能力
 不能像数组一样，给一个索引直接从这个数组拿出索引对应的数据，数组所开辟的空间在内存里是连续的。链表是通过next找下一个节点的。在内存里不一定是连续的。
 最简单的动态数据结构
 数据存储在节点中(Node)
 最后节点的next是NULL
 数组和链表对比：
   数组最好用于索引有语义的情况。
   最大的优点支持快速查询
   链表不适合用于索引有语义的情况
   最大优点：动态
 链表实现中常用的虚拟头节点
 对链表头进行增、删和查时间复杂度是O(1)
 链表队列：
   从head或是tail端添加元素都是很容易的
   从tail端删除元素不容易
   从head端删除元素，从tail端插入元素
   不牵扯到对链表中间的元素进行操作，不需要设置虚拟头节点，要注意链表为空的情况

 递归：
   将原来的问题转化为更小的同一问题
   递归调用是有代价的：函数调用+系统栈空间
   近乎和链表相关的所有操作，都可以使用递归的形式完成

 树结构：
   数据使用树结构存储，出奇的高效
 二分搜索树(Binary Search Tree)：
   二叉树：
     和链表一样，动态数据结构
     对每个节点来说，最多只能分成两个节点(左孩子、右孩子)
     具有唯一根节点
     一个节点没有任何子节点的叫做叶子节点
     每个节点最多有一个父节点
     具有天然递归结构
     每个节点的左右字数都是二叉树
     二叉树不一定是满的，就是说对于每一个节点来说不一定都有左右两个孩子
     一个节点也是二叉树，只不过左右两个孩子都是空
   二分搜索树是二叉树
   二分搜索树每个节点的值都要大于其左子树的所有节点的值
   二分搜索树每个节点的值都要小于其右子树的所有节点的值
   每一个子树都是二分搜索树
   存储的元素具有可比较性
   想要包含重复元素，只要定义左子树小于等于节点，或者右子树大于等于节点
   深度优先遍历：
     二分搜索树前序遍历 访问左右字数，最自然的一种遍历方式，也是最常用的
     二分搜索树中序遍历 访问该节点放在遍历这个节点的左右子树中间 遍历的结果就是在二分搜索树存储的排序后的结果
     二分搜索树后序遍历 应用：为二分搜索树释放内存
   广度优先遍历(层序遍历)：

 集合和映射(Map)：
  集合：
    不会重复，因为二分搜索树忽略了重复的数据
    应用：客户统计、词汇量统计
    二分搜索树和链表都属于动态的数据结构
    logn这个复杂度是非常快的时间复杂度
    有序集合基于搜索树实现的
    无序集合基于哈希表实现
    多重集合元素可以重复
  映射：
    存储数据对的数据结构(Key，Value)
    根据键寻找值

 堆和优先队列：
   优先队列：
     普通对列：先进先出，后进后出
     优先队列：出队顺序和入队顺序无关，和优先级相关
   动态选择优先级最高的任务执行
   二叉堆是一个完全的二叉树,除了叶子节点其他所有的节点左右孩子都不为空
   把元素顺序排列成树的形状，得到的就是一个完全二叉树
   二叉堆性质：堆中某个节点的值总是不大于其父节点的值(最大堆)
   用数组存储二叉堆
     parent(i) = (i-1) / 2
     left child (i) = 2*i+1
     right child (i) = 2*i+2
 线段树(区间树)Segment Tree
   为什么使用线段树：
     对于有一类问题我们关心的是线段或是区间
   线段树不是完全二叉树
   线段树是平衡二叉树：最大深度和最小深度相差为1
   堆也是平衡二叉树
   区间有n个元素，用数组存储需要4n的静态空间即可
 Trie 字典树 前缀树
   每个节点有若干个指向下一个节点的指针
   局限性：空间占用大
   压缩字典树，节省空间，但是维护成本高
   Ternary Search Tree 三分搜索树
   后缀树 解决字符串模式识别
 并查集 Union Find
   一种很不一样的数据结构，孩子指向父亲数据结构，解决连接问题
   连接问题
     网络(抽象概念，如关系网，不是指互联网)中节点间连接状态
     数学组集合类实现
   并查集优化：
     基于size优化
     基于rank优化
     路径压缩

 AVL树
   最早的自平衡二分搜索树结构
   平衡二叉树：满的二叉树、完全二叉树、线段树
   对于任一节点来说，左子树和右子树的高度差不能超过1
   平衡二叉树的高度和节点数量之间的关系也是O(logn)的
   平衡因子：对于每个节点来说，它的左右子树的高度差
   AVL实现自平衡机制: 不会退化成链表
     左右旋转
 红黑树
   二分搜索树
   性质：
     每个节点或者是红色或者是黑色
     根节点是黑色的
     最后的空节点是黑色的
     如果一个节点是红色的，那么他的孩子节点是黑色的
     从任意节点到叶子节点，经过的黑色节点是一样的
   红黑树与2-3树等价的
   2-3树性质：
     满足二分搜索树基本性质
     节点可以存放一个或两个元素
     每个节点可以有两个孩子或者三个孩子
     绝对平衡的树，对于任意一个节点左右子树高度一定相等